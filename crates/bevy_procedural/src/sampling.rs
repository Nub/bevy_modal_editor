//! Sampling trait and types for procedural placement.

use bevy::mesh::{Indices, VertexAttributeValues};
use bevy::prelude::*;

/// A sample point generated by sampling a source.
#[derive(Debug, Clone)]
pub struct Sample {
    /// Local-space position of the sample.
    pub position: Vec3,
    /// Orientation information (tangent/up vectors).
    pub orientation: SampleOrientation,
    /// Parameter value in range [0, 1] representing position along source.
    pub parameter: f32,
}

/// Orientation information for a sample point.
#[derive(Debug, Clone, Default)]
pub struct SampleOrientation {
    /// Tangent direction at the sample point (e.g., spline direction).
    pub tangent: Option<Vec3>,
    /// Up direction at the sample point (e.g., surface normal).
    pub up: Option<Vec3>,
}

impl SampleOrientation {
    /// Create an orientation with no direction information.
    pub fn none() -> Self {
        Self::default()
    }

    /// Create an orientation with just a tangent.
    pub fn with_tangent(tangent: Vec3) -> Self {
        Self {
            tangent: Some(tangent),
            up: None,
        }
    }

    /// Create an orientation with just an up vector.
    pub fn with_up(up: Vec3) -> Self {
        Self {
            tangent: None,
            up: Some(up),
        }
    }

    /// Create an orientation with tangent and up vectors.
    pub fn with_tangent_and_up(tangent: Vec3, up: Vec3) -> Self {
        Self {
            tangent: Some(tangent),
            up: Some(up),
        }
    }
}

/// Trait for types that can be sampled for procedural placement.
///
/// Implement this trait to enable `ProceduralPlacer` support for custom types.
pub trait Sampling {
    /// Generate sample points.
    ///
    /// # Arguments
    /// * `count` - Number of samples to generate
    /// * `uniform` - If true, samples are evenly distributed; if false, randomly distributed
    /// * `seed` - Optional seed for random sampling
    ///
    /// # Returns
    /// Vector of samples in local space.
    fn sample(&self, count: usize, uniform: bool, seed: Option<u64>) -> Vec<Sample>;
}

// ============================================================================
// Mesh sampling implementation
// ============================================================================

impl Sampling for Mesh {
    fn sample(&self, count: usize, uniform: bool, seed: Option<u64>) -> Vec<Sample> {
        if count == 0 {
            return Vec::new();
        }

        // Extract positions from mesh
        let Some(positions) = self.attribute(Mesh::ATTRIBUTE_POSITION) else {
            return Vec::new();
        };

        let positions: Vec<Vec3> = match positions {
            VertexAttributeValues::Float32x3(vals) => {
                vals.iter().map(|v| Vec3::new(v[0], v[1], v[2])).collect()
            }
            _ => return Vec::new(),
        };

        if positions.is_empty() {
            return Vec::new();
        }

        // Get normals if available
        let normals: Option<Vec<Vec3>> = self.attribute(Mesh::ATTRIBUTE_NORMAL).and_then(|n| {
            match n {
                VertexAttributeValues::Float32x3(vals) => {
                    Some(vals.iter().map(|v| Vec3::new(v[0], v[1], v[2])).collect())
                }
                _ => None,
            }
        });

        // Build triangles from indices or assume triangle list
        let triangles = build_triangles(&positions, self.indices(), normals.as_deref());

        if triangles.is_empty() {
            // Fall back to sampling vertices directly
            return sample_vertices(&positions, normals.as_deref(), count, uniform, seed);
        }

        if uniform {
            sample_triangles_uniform(&triangles, count)
        } else {
            sample_triangles_random(&triangles, count, seed)
        }
    }
}

/// A triangle with positions and normals for sampling.
#[derive(Clone)]
struct Triangle {
    positions: [Vec3; 3],
    normals: [Vec3; 3],
    area: f32,
}

impl Triangle {
    fn new(p0: Vec3, p1: Vec3, p2: Vec3, n0: Vec3, n1: Vec3, n2: Vec3) -> Self {
        let edge1 = p1 - p0;
        let edge2 = p2 - p0;
        let area = edge1.cross(edge2).length() * 0.5;

        Self {
            positions: [p0, p1, p2],
            normals: [n0, n1, n2],
            area,
        }
    }

    /// Sample a random point on this triangle using barycentric coordinates.
    fn sample_point(&self, u: f32, v: f32) -> (Vec3, Vec3) {
        // Use sqrt for uniform distribution
        let su = u.sqrt();
        let bary = Vec3::new(1.0 - su, su * (1.0 - v), su * v);

        let position = self.positions[0] * bary.x
            + self.positions[1] * bary.y
            + self.positions[2] * bary.z;

        let normal = (self.normals[0] * bary.x
            + self.normals[1] * bary.y
            + self.normals[2] * bary.z)
            .normalize_or_zero();

        (position, normal)
    }
}

fn build_triangles(
    positions: &[Vec3],
    indices: Option<&Indices>,
    normals: Option<&[Vec3]>,
) -> Vec<Triangle> {
    let mut triangles = Vec::new();

    let get_normal = |idx: usize| -> Vec3 {
        normals
            .and_then(|n| n.get(idx).copied())
            .unwrap_or(Vec3::Y)
    };

    match indices {
        Some(Indices::U16(idx)) => {
            for tri in idx.chunks(3) {
                if tri.len() == 3 {
                    let i0 = tri[0] as usize;
                    let i1 = tri[1] as usize;
                    let i2 = tri[2] as usize;

                    if i0 < positions.len() && i1 < positions.len() && i2 < positions.len() {
                        triangles.push(Triangle::new(
                            positions[i0],
                            positions[i1],
                            positions[i2],
                            get_normal(i0),
                            get_normal(i1),
                            get_normal(i2),
                        ));
                    }
                }
            }
        }
        Some(Indices::U32(idx)) => {
            for tri in idx.chunks(3) {
                if tri.len() == 3 {
                    let i0 = tri[0] as usize;
                    let i1 = tri[1] as usize;
                    let i2 = tri[2] as usize;

                    if i0 < positions.len() && i1 < positions.len() && i2 < positions.len() {
                        triangles.push(Triangle::new(
                            positions[i0],
                            positions[i1],
                            positions[i2],
                            get_normal(i0),
                            get_normal(i1),
                            get_normal(i2),
                        ));
                    }
                }
            }
        }
        None => {
            // Assume triangle list without indices
            for tri in positions.chunks(3) {
                if tri.len() == 3 {
                    let base_idx = triangles.len() * 3;
                    triangles.push(Triangle::new(
                        tri[0],
                        tri[1],
                        tri[2],
                        get_normal(base_idx),
                        get_normal(base_idx + 1),
                        get_normal(base_idx + 2),
                    ));
                }
            }
        }
    }

    triangles
}

fn sample_triangles_uniform(triangles: &[Triangle], count: usize) -> Vec<Sample> {
    if triangles.is_empty() || count == 0 {
        return Vec::new();
    }

    // Build cumulative area distribution
    let total_area: f32 = triangles.iter().map(|t| t.area).sum();
    if total_area <= 0.0 {
        return Vec::new();
    }

    let mut cumulative_areas = Vec::with_capacity(triangles.len());
    let mut sum = 0.0;
    for tri in triangles {
        sum += tri.area / total_area;
        cumulative_areas.push(sum);
    }

    // Use deterministic sampling for uniform distribution
    let mut samples = Vec::with_capacity(count);

    for i in 0..count {
        // Stratified sampling: divide [0,1] into count bins
        let t = (i as f32 + 0.5) / count as f32;

        // Find triangle for this t value
        let tri_idx = cumulative_areas
            .iter()
            .position(|&a| a >= t)
            .unwrap_or(triangles.len() - 1);

        let tri = &triangles[tri_idx];

        // Use deterministic barycentric coordinates based on index
        let u = ((i * 7919) % 1000) as f32 / 1000.0;
        let v = ((i * 7907) % 1000) as f32 / 1000.0;

        let (position, normal) = tri.sample_point(u, v);

        samples.push(Sample {
            position,
            orientation: SampleOrientation::with_up(normal),
            parameter: if count > 1 {
                i as f32 / (count - 1) as f32
            } else {
                0.5
            },
        });
    }

    samples
}

fn sample_triangles_random(triangles: &[Triangle], count: usize, seed: Option<u64>) -> Vec<Sample> {
    if triangles.is_empty() || count == 0 {
        return Vec::new();
    }

    let mut rng = if let Some(s) = seed {
        fastrand::Rng::with_seed(s)
    } else {
        fastrand::Rng::new()
    };

    // Build cumulative area distribution
    let total_area: f32 = triangles.iter().map(|t| t.area).sum();
    if total_area <= 0.0 {
        return Vec::new();
    }

    let mut cumulative_areas = Vec::with_capacity(triangles.len());
    let mut sum = 0.0;
    for tri in triangles {
        sum += tri.area / total_area;
        cumulative_areas.push(sum);
    }

    let mut samples = Vec::with_capacity(count);

    for i in 0..count {
        // Pick triangle weighted by area
        let t = rng.f32();
        let tri_idx = cumulative_areas
            .iter()
            .position(|&a| a >= t)
            .unwrap_or(triangles.len() - 1);

        let tri = &triangles[tri_idx];

        // Random barycentric coordinates
        let u = rng.f32();
        let v = rng.f32();

        let (position, normal) = tri.sample_point(u, v);

        samples.push(Sample {
            position,
            orientation: SampleOrientation::with_up(normal),
            parameter: if count > 1 {
                i as f32 / (count - 1) as f32
            } else {
                0.5
            },
        });
    }

    samples
}

fn sample_vertices(
    positions: &[Vec3],
    normals: Option<&[Vec3]>,
    count: usize,
    uniform: bool,
    seed: Option<u64>,
) -> Vec<Sample> {
    if positions.is_empty() || count == 0 {
        return Vec::new();
    }

    if uniform {
        // Evenly spaced vertices
        let step = positions.len() as f32 / count as f32;
        (0..count)
            .map(|i| {
                let idx = ((i as f32 * step) as usize).min(positions.len() - 1);
                let normal = normals.and_then(|n| n.get(idx).copied()).unwrap_or(Vec3::Y);

                Sample {
                    position: positions[idx],
                    orientation: SampleOrientation::with_up(normal),
                    parameter: if count > 1 {
                        i as f32 / (count - 1) as f32
                    } else {
                        0.5
                    },
                }
            })
            .collect()
    } else {
        let mut rng = if let Some(s) = seed {
            fastrand::Rng::with_seed(s)
        } else {
            fastrand::Rng::new()
        };

        (0..count)
            .map(|i| {
                let idx = rng.usize(0..positions.len());
                let normal = normals.and_then(|n| n.get(idx).copied()).unwrap_or(Vec3::Y);

                Sample {
                    position: positions[idx],
                    orientation: SampleOrientation::with_up(normal),
                    parameter: if count > 1 {
                        i as f32 / (count - 1) as f32
                    } else {
                        0.5
                    },
                }
            })
            .collect()
    }
}
